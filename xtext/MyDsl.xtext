// automatically generated by Xtext
grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

import "platform:/resource/requirements_editor/model/requirements_editor.ecore" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

DocumentRoot returns DocumentRoot:
	{DocumentRoot}
	'DocumentRoot'
	'{'
		('rootCategories' '{' rootCategories+=Category ( "," rootCategories+=Category)* '}' )?
		('person' '{' person+=Person ( "," person+=Person)* '}' )?
	'}';



Requirement returns Requirement:
	QualityRequirement | FunctionalRequirement;

Description returns Description:
	TextualDescription;

Dependency returns Dependency:
	Refines | ICost | CValue | Requires;

Argument returns Argument:
	BinaryOperatorArgument | RequirementArgument | NOTOperator;

Category returns Category:
	'Category'
	name=EString
	'{'
		'categoryOwnedBy' categoryOwnedBy=[Person|EString]
		('subcategoryOf' '{' subcategoryOf+=Category ( "," subcategoryOf+=Category)* '}' )?
		('requirement' '{' requirement+=Requirement ( "," requirement+=Requirement)* '}' )?
	'}';

Person returns Person:
	{Person}
	'Person'
	'{'
		('firstname' firstname=EString)?
		('lastname' lastname=EString)?
		('personOwnsRequirement' '(' personOwnsRequirement+=[Requirement|EString] ( "," personOwnsRequirement+=[Requirement|EString])* ')' )?
		('personOwnsCategory' '(' personOwnsCategory+=[Category|EString] ( "," personOwnsCategory+=[Category|EString])* ')' )?
	'}';

EString returns ecore::EString:
	STRING | ID;

EInt returns ecore::EInt:
	'-'? INT;

EBoolean returns ecore::EBoolean:
	'true' | 'false';

QualityRequirement returns QualityRequirement:
	(isMandatory?='isMandatory')?
	'QualityRequirement'
	name=EString
	'{'
		('identifier' identifier=EString)?
		('priority' priority=EInt)?
		'requirementOwnedBy' requirementOwnedBy=[Person|EString]
		'description' description=Description
		('dependencySource' '{' dependencySource+=Dependency ( "," dependencySource+=Dependency)* '}' )?
	'}';

FunctionalRequirement returns FunctionalRequirement:
	(isMandatory?='isMandatory')?
	'FunctionalRequirement'
	name=EString
	'{'
		('identifier' identifier=EString)?
		('priority' priority=EInt)?
		'requirementOwnedBy' requirementOwnedBy=[Person|EString]
		'description' description=Description
		('dependencySource' '{' dependencySource+=Dependency ( "," dependencySource+=Dependency)* '}' )?
	'}';

TextualDescription returns TextualDescription:
	{TextualDescription}
	'TextualDescription'
	'{'
		('description' description=EString)?
	'}';

Refines returns Refines:
	'Refines'
	'{'
		('comment' comment=EString)?
		'dependencyTarget' dependencyTarget=[Requirement|EString]
	'}';

ICost returns ICost:
	'ICost'
	'{'
		('comment' comment=EString)?
		'dependencyTarget' dependencyTarget=[Requirement|EString]
	'}';

CValue returns CValue:
	'CValue'
	'{'
		('comment' comment=EString)?
		'dependencyTarget' dependencyTarget=[Requirement|EString]
	'}';

Requires returns Requires:
	'Requires'
	'{'
		'argument' argument=Argument
	'}';

BinaryOperatorArgument returns BinaryOperatorArgument:
	'BinaryOperatorArgument'
	'{'
		('operator' operator=BinaryOperator)?
		'rightSideArgument' rightSideArgument=Argument
		'leftSideArgument' leftSideArgument=Argument
	'}';

RequirementArgument returns RequirementArgument:
	'RequirementArgument'
	'{'
		'requirement' requirement=[Requirement|EString]
	'}';

NOTOperator returns NOTOperator:
	'NOTOperator'
	'{'
		'argument' argument=Argument
	'}';

enum BinaryOperator returns BinaryOperator:
				OR = 'OR' | AND = 'AND';
