// automatically generated by Xtext
grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

import "platform:/resource/requirements_editor/model/requirements_editor.ecore" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

DocumentRoot returns DocumentRoot:// hidden(WS, ML_COMMENT, SL_COMMENT):
	{DocumentRoot}
	'RequirementsSpecification'
	'{'
		('categories' ':' '[' (rootCategories+=Category)("," rootCategories+=Category)* ']' "," )
		('persons' ':' '[' person+=Person ( "," person+=Person)* ']' )
	'}';



Requirement returns Requirement:
	QualityRequirement | FunctionalRequirement;

Description returns Description:
	TextualDescription;

Dependency returns Dependency:
	Refines | ICost | CValue | Requires;

Argument returns Argument:
	RequirementArgument | NOTOperator | BinaryOperatorArgument;

Category returns Category:
	'Category'
	name=EString
	'{'
		'categoryResponsible' ':' categoryOwnedBy=[Person|EString]
		("," 'subcategories' ':' '[' subcategoryOf+=Category ( "," subcategoryOf+=Category)* ']')?
		("," 'requirements' ':' '[' requirement+=Requirement ( "," requirement+=Requirement)* ']' )?
	'}';

Person returns Person:
	'Person'
	name=EString
	'{'

	'}';

EString returns ecore::EString:
	STRING | ID;

EInt returns ecore::EInt:
	'-'? INT;

EBoolean returns ecore::EBoolean:
	'true' | 'false';

QualityRequirement returns QualityRequirement:
	'QualityRequirement'
	name=EString
	'{'
		(isMandatory?='mandatory' ",")?
		'id' ':' identifier=EString ","
		'priority' ':' priority=EInt ","
		'requirementResponsible' ':' requirementOwnedBy=[Person|EString] ","
		'description' ':' description=Description
		("," 'dependsOn' ':' '[' (dependencySource+=Dependency)("," dependencySource+=Dependency)* ']' )?
	'}';

FunctionalRequirement returns FunctionalRequirement:
	'FunctionalRequirement'
	name=EString
	'{'
		(isMandatory?='mandatory' ",")?
		'id' ':' identifier=EString ","
		'priority' ':' priority=EInt ","
		'requirementResponsible' ':' requirementOwnedBy=[Person|EString] ","
		'description' ':' description=Description
		("," 'dependsOn' ':' '[' (dependencySource+=Dependency)("," dependencySource+=Dependency)*  ']' )?
	'}';

TextualDescription returns TextualDescription:
	{TextualDescription}
		description=EString;

Refines returns Refines:
	'Refines' ':'
		dependencyTarget=[Requirement|EString]
		('comment' ':' comment=EString)?;

ICost returns ICost:
	'ICost' ':'
		dependencyTarget=[Requirement|EString]
		('comment' ':' comment=EString)?;

CValue returns CValue:
	'CValue' ':'
		dependencyTarget=[Requirement|EString]
		('comment' ':' comment=EString)?;

Requires returns Requires:
	'Requires' ':'
		argument=Argument;

BinaryOperatorArgument returns BinaryOperatorArgument:
	leftSideArgument=ParenthesizedArgument operator=BinaryOperator rightSideArgument=Argument;

ParenthesizedArgument returns Argument:
	RequirementArgument | '(' NOTOperator ')' | '(' BinaryOperatorArgument ')'
;

RequirementArgument returns RequirementArgument:
	requirement=[Requirement|EString];

NOTOperator returns NOTOperator:
	'NOT' argument=Argument;

enum BinaryOperator returns BinaryOperator:
				OR = 'OR' | AND = 'AND';
